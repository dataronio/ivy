(* Main file for generating reference counting code 
   Comments:
     - we can do better on local structs whose address is not taken
 *)

open Cil
open Pretty
open Sutil
open Sfunctions
open Rcutils
open Rclocals
open Rcinit
open Dcheckdef

open Rc

module DU = Dutil
module L = List
module E = Errormsg
module H = Hashtbl
module S = String

module UD = Usedef
module VS = UD.VS

let cRcAdjustForType (fi:file) (inGlob:varinfo) (t:typ) (loc:location) : varinfo =
  let rec baseType t =
    match t with
    | TPtr (ti,_) -> ("ptr_" ^ typeName ti, "void *", t)
    | TComp (ci, _) when typeContainsCountedPointers t -> 
                (ci.cname, compFullName ci, t)
    | TArray (ta, _, _) -> baseType ta
    | TNamed (ti, _) -> baseType ti.ttype
    | TInt (_,_) | TFloat (_,_) | TEnum (_,_) 
                when !Ivyoptions.typeDebug -> 
                        ("rcbasic", "nonptr type", TInt(IUInt,[]))
    | TInt (IChar, _) ->
	    if !Ivyoptions.warnTypeofChar then
	      ignore(warnLoc loc "type of 'char' requested");
	    raise NoRcPointers
    | _ -> raise NoRcPointers in 
  let (basename, nicename, t') = baseType t in
  let name = "crc_adjust_" ^ basename in
  let (vi, isNew) = findFunction fi name rcTypes.crc_adjust in
  if not (H.mem adjustFunctions vi) then
    (* We're seeing this "crc_adjust..." function for the first time *)
    if isNew then
      begin
	H.add adjustFunctions vi true;
	H.add autoGeneratedAdjustFunctions name true;
	(* If the user declared no "crc_adjust..." function, try to generate
	   one just before 'inGlob' (see rcprint.ml for details) *)
	if typeContainsUnionWithCountedPointers t' then begin
	  let msgLoc = if !Ivyoptions.fakeAdjust then warnLoc else errorLoc in
          ignore(msgLoc loc "need handwritten crc_adjust function for %s called %s" nicename name)
	end;
	vi.vstorage <- Static; (* Generated crc_adjust functions are static *)
      end
    else
      begin
	(* Add a prototype for vi to the start of the file - it may
	   be declared after inGlob. We make a new fake varinfo because
	   the actual one may refer to typedefs (especially size_t) *)
	let fakeVi = makeGlobalVar name rcTypes.crc_adjust in
	fakeVi.vstorage <- vi.vstorage;
	declareEarly fi fakeVi;
	H.add adjustFunctions fakeVi true
      end;
  (* Remember the auto-generated crc_adjust functions needed by inGlob *)
  if H.mem autoGeneratedAdjustFunctions name then
    H.add adjustFunctionsToAdd inGlob (name, t');
  vi

let cRcAdjustSize (fi : file) (inFn : fundec) (lv : lval)
                  (by:int) (size : exp) (loc : location) : instr =
  let adjustor = cRcAdjustForType fi inFn.svar (typeOfLval lv) loc in
  Call(None, (v2e rcFunctions.crcadjust),
       [v2e adjustor; mkAddrOf lv; integer by; size; zero], loc)

let cRcInvalidateSize (fi : file) (inFn : fundec) (vi : varinfo)
                      (size : exp) (loc : location) : instr =
  let adjustor = cRcAdjustForType fi inFn.svar vi.vtype loc in
  Call(None, (v2e rcFunctions.crcadjust),
       [v2e adjustor;AddrOf(Var vi,NoOffset);zero;size;one], loc)

let cRcAdjust (fi : file) (inFn : fundec) (lv : lval) (by:int) (loc : location) : instr =
  (* XXX: zero should be replaced by an expression for the size taken from the
     Deputy bounds attribute *)
  (*let _, hi = Dcheck.boundsForLval inFn lv in
  let _ = BinOp(MinusA, CastE(uintType,hi), CastE(uintType,Lval lv),uintType) in*)
  cRcAdjustSize fi inFn lv by zero loc
  
let cRcInvalidate (fi : file) (inFn : fundec) (vi : varinfo) (loc : location) : instr =
  (*let _, hi = Dcheck.boundsForLval inFn (var vi) in
  let _ = BinOp(MinusA, CastE(uintType,hi), CastE(uintType,v2e vi),uintType) in*)
  cRcInvalidateSize fi inFn vi zero loc

let coPushInstr (vi : varinfo) (loc : location) : instr =
  let var = CastE(voidPtrType,mkAddrOf (Var vi, NoOffset)) in
  Call(None, (v2e rcFunctions.cpush), [var], loc) 

let coPopInstr (vi : varinfo) (loc : location) : instr =
  let var = CastE(voidPtrType, mkAddrOf (Var vi, NoOffset)) in
  Call(None, (v2e rcFunctions.cpop), [var], loc)

let tempVar (vi:varinfo) = 
  let n = vi.vname in
  try
    S.sub n 0 3 = "__d"
  with Invalid_argument _ -> false

let nonTemps (vl:varinfo list) = 
  L.filter (fun vi -> not (tempVar vi)) vl

class varReadFinder (needle : varinfo) (found : bool ref) = object(self)
    inherit nopCilVisitor

    method vvrbl (vi : varinfo) =
        if vi.vid = needle.vid then
            found := true;
        SkipChildren

end

(* Wrap all assignments with 
   concurrent reference count operations (i.e., calls to the appropriate
   "crc_adjust..." function. Also invalidate locals when they die. *)
class cRcAssignments (fi:file) (oVars:varinfo list) (dVars:VS.t)
    : cilVisitor =  object (self)
    inherit Liveness.deadnessVisitorClass as super

    val currentFn : fundec ref = ref dummyFunDec;
    method vfunc (f:fundec) =
      currentFn := f;
      DoChildren

    method private collectDead (loc : location) : instr list = 
        VS.fold
            (fun vi il ->
                if L.memq vi oVars && VS.mem vi dVars then
                    (*(Set((Var vi,NoOffset),CastE(voidPtrType,zero),loc)) :: il*)
                    (coPopInstr vi loc):: il
                else il)
            (VS.diff post_dead_vars (VS.inter post_dead_vars post_live_vars))
            []

    method private varRead (lv : lval) (vi : varinfo) : bool =
        let found = ref false in
        match lv with
        | (Mem e, off) ->
            ignore(visitCilLval (new varReadFinder vi found) lv);
            !found
        | (_, off) ->
            ignore(visitCilOffset (new varReadFinder vi found) off);
            !found

    method private argPushDead (loc : location) 
                               (lvo : lval option)
                               : instr list * instr list
        =
        let to_cpop, pdv =
            match lvo with
            | None -> VS.empty, post_dead_vars
            | Some lv ->
                VS.partition (self#varRead lv) post_dead_vars
        in
        VS.fold
            (fun vi il ->
                if L.memq vi oVars && VS.mem vi dVars then
                    let var = CastE(voidPtrType, mkAddrOf(Var vi, NoOffset)) in
                    (Call(None,v2e rcFunctions.argpush,[var],loc)) :: il
                else il)
            pdv
            [],
        VS.fold
            (fun vi il ->
                if L.memq vi oVars && VS.mem vi dVars then
                    (*(Set((Var vi,NoOffset),CastE(voidPtrType,zero),loc)) :: il*)
                    (coPopInstr vi loc):: il
                else il)
            to_cpop
            []

    method private collectLive (loc : location) : instr list =
        VS.fold
            (fun vi il ->
                if L.memq vi oVars && VS.mem vi dVars then
                    (coPushInstr vi loc) :: il
                else il)
            (VS.diff post_live_vars (VS.inter post_live_vars post_dead_vars))
            []

    method private collectLiveDead (loc : location) : instr list =
        VS.fold
            (fun vi il ->
                if L.memq vi oVars && VS.mem vi dVars then
                    (coPushInstr vi loc) :: il
                else il)
            (VS.inter post_live_vars post_dead_vars)
            []

    method vinst (i:instr) =
      ignore(super#vinst i);

      let needsRefCount lv = match lv with
      | Var vi, NoOffset when L.memq vi oVars || tempVar vi -> false
      | _ when typeContainsCountedPointers (typeOfLval lv) ->
          let refd = UD.computeUseExp (Lval lv) in
          VS.exists (fun vi -> VS.mem vi dVars) refd
            (* true*)
      | _ when !Ivyoptions.typeDebug -> true
      | _ -> false
      in

      match i with
      | Set((_, offset), _, loc) when isBitfield offset ->
          ChangeTo (i :: (self#collectDead loc))
      | Set(lv, value, loc) when needsRefCount lv ->
          (*if isZero value then
              ChangeTo ((self#collectLive loc) @ [
                cRcAdjust fi !currentFn lv (-1) loc;
                i] @ (self#collectDead loc))
          else*)
              ChangeTo ((self#collectLive loc) @ [
                cRcAdjust fi !currentFn lv (-1) loc; 
                i;
                cRcAdjust fi !currentFn lv 1 loc ] @ (self#collectDead loc))
      | Call(Some lv, Lval(Var fv,NoOffset),[src],loc)
        when (fv.vname = "SINIT" || fv.vname = "SINIT_DOUBLE" ||
              fv.vname = "SINIT_FLOAT") ->
            if needsRefCount lv then
                ChangeTo ((self#collectLive loc) @ [
                    cRcAdjust fi !currentFn lv (-1) loc;
                    i;
                    cRcAdjust fi !currentFn lv 1 loc ] @ (self#collectDead loc))
            else ChangeTo ((self#collectLive loc) @ [i] @ (self#collectDead loc))
      | Call(Some lv, func, args, loc) when needsRefCount lv ->
            let tmp = Sattrconv.mkTemp fi !currentFn lv "ctmp" (sharCTypeOfLval lv) in
            let tmplv = Var tmp, NoOffset in
            let argpushes, topop = self#argPushDead loc (Some lv) in
            let argnulls = if argpushes <> [] then
                [Call (None, v2e rcFunctions.argnull,[],loc)] else []
            in
            ChangeTo (
                (self#collectLive loc) @
                argpushes @ [Call (Some tmplv, func, args, loc)] @
                [Call (None, v2e rcFunctions.retnull, [], loc);
                cRcAdjust fi !currentFn lv (-1) loc;
                Set (lv,Lval tmplv,loc);
                cRcAdjust fi !currentFn lv 1 loc ] @ argnulls @ topop)
      | Call(Some lv, func, args, loc) ->
            let tmp = Sattrconv.mkTemp fi !currentFn lv "ctmp" (sharCTypeOfLval lv) in
            let tmplv = Var tmp, NoOffset in
            let argpushes, topop = self#argPushDead loc (Some lv) in
            let argnulls = if argpushes <> [] then
                [Call (None, v2e rcFunctions.argnull,[],loc)] else []
            in
            let retnulls = [Call(None, v2e rcFunctions.retnull, [], loc)]
            in
            let livedeads = self#collectLiveDead loc in
            ChangeTo (
                (self#collectLive loc) @
                argpushes @ [Call (Some tmplv, func, args, loc)] @
                argnulls @
                livedeads @
                [Set(lv, Lval tmplv, loc)] @
                retnulls @ topop)
      | Call(None,_,_,loc) ->
            let argpushes, _ = self#argPushDead loc None in
            let argnulls = if argpushes <> [] then
                [Call (None, v2e rcFunctions.argnull,[],loc)] else []
            in
            let retnulls = [Call(None, v2e rcFunctions.retnull, [], loc)]
            in
            ChangeTo ((self#collectLive loc) @ argpushes @ 
                      (i :: argnulls) @ retnulls)
      | Set(_,_,loc) -> ChangeTo ((self#collectLive loc) @ (i :: (self#collectDead loc)))
      | Asm _ -> DoChildren

    (* Null out vars that die between statements *)
    method vstmt (s : stmt) =
        ignore(super#vstmt s);
        let deathInstrs = self#collectDead locUnknown in
        let liveInstrs = self#collectLive locUnknown in
        match deathInstrs, liveInstrs with
        | [], [] -> DoChildren
        | di, [] ->
            ChangeDoChildrenPost(s, fun s ->
                s.skind <- Block(mkBlock [mkStmt(Instr di);mkStmt s.skind]);
                s)
        | [], li ->
            ChangeDoChildrenPost(s, fun s ->
                s.skind <- Block(mkBlock [mkStmt(Instr li);mkStmt s.skind]);
                s)
        | di, li ->
            ChangeDoChildrenPost(s, fun s ->
                s.skind <- Block(mkBlock [mkStmt(Instr(li@di));mkStmt s.skind]);
                s)
end


(* Unoptimized formals must have some initialization that is visible to
   the reference counting algorithm. So do the following at the beginning
   of the function:
   1. move args into temps.
   2. null out args.
   3. move temps into args. *)
let cRcOnEntry (fi:file) (f:fundec) (aParms:varinfo list) (loc:location) : unit =
    let argIniter vi : instr list =
        match unrollType vi.vtype with
        | TPtr _ ->
            let tmp = makeTempVar f ~name:"__arginit" vi.vtype in
            [Set(var tmp,v2e vi,loc);
             Set(var vi,CastE(voidPtrType,zero),loc);
             cRcAdjust fi f (var vi) (-1) loc;
             Set(var vi,v2e tmp,loc);
             cRcAdjust fi f (var vi) 1 loc;]
        | _ ->
            [cRcAdjust fi f (var vi) 1 loc;]
    in
    let instrs = L.concat (L.map argIniter aParms) in
    let stmt = mkStmt (Instr instrs) in
    f.sbody.bstmts <- stmt :: f.sbody.bstmts

(* Generate a call to __builtin_ipush/ipop for variable 'vi' at 
   location 'loc' in function 'f' of file 'fi' *)
let cIPushPopCall (push:varinfo) (fi:file) (f:fundec) (vi:varinfo) (loc:location) : instr =
  let typeVi = cRcAdjustForType fi f.svar vi.vtype loc in
  let var = mkAddrOf (Var vi, NoOffset) in
  Call(None, (v2e push), [ var; (v2e typeVi); SizeOfE (v2e vi) ], loc)

let cPushOnEntry (fi : file) (f : fundec) (uVars : varinfo list)
                 (oVars : varinfo list) (loc : location) : unit =
  let push vi =
      if List.memq vi oVars then
          (* cpush vars that are live on entry *)
          try
          (*if VS.mem vi (Liveness.getLiveness (List.hd f.sbody.bstmts)) then
            [coPushInstr vi loc]
          else*) []
          with Not_found -> (E.log "cPushOnEntry: %s gave Not_found\n" f.svar.vname;[])
      else
          [cIPushPopCall rcFunctions.cipush fi f vi loc ]
  in
  let pushInstrs = L.concat (L.map push (nonTemps uVars)) in
  let nullargInstr =
    let iVars = oVars @ uVars in
    if List.exists (fun vi -> List.mem vi iVars) f.sformals then
        [Call(None,v2e rcFunctions.argnull, [], loc)]
    else []
  in
  let pushStmt = mkStmt (Instr(pushInstrs@nullargInstr)) in
  f.sbody.bstmts <- [pushStmt] @ f.sbody.bstmts

(* On exit, dereference and pop from parallel stack all locals in 'vars' *)
(* Also, invalidate things in uVars *)
class cRcOnExit (fi:file) (uVars : varinfo list) (oVars : varinfo list) : cilVisitor = 
  object (self)
    inherit nopCilVisitor as super

    val currentFn : fundec ref = ref dummyFunDec;
    method vfunc (f:fundec) =
      currentFn := f;
      DoChildren

    method vstmt (s:stmt) = 
      begin
        match s.skind with
        | Return(_, loc) -> 
	    (* Add calls to "__builtin_ipop" just before the return
	       (the dereference is in the implementation of ipop *)
	    let popRc vi =
	          (* use zero for size if vi isn't an array as that produces better
		     code when inlining the rc_adjust function (a 0 size argument
		     to rc_adjust means "assume it's not an array") *)
	        let viSize = 
		        if isArrayType vi.vtype then
		          SizeOfE (v2e vi)
		        else
		          zero
	        in
            [cRcInvalidateSize fi !currentFn vi viSize loc;
	         cIPushPopCall rcFunctions.cipop fi !currentFn vi loc]
        in
        let u, _ = Usedef.computeUseDefStmtKind s.skind in
        let retRc vi =
            if VS.mem vi u then
                let var = mkAddrOf (Var vi, NoOffset) in
                [Call(None, v2e rcFunctions.retpush, [var], loc)]
            else []
        in
        let corets = L.concat (L.map retRc oVars) in
	    let popInstr = Instr (corets @ (L.concat (L.map popRc (nonTemps uVars)))) in
	    let popStmt = mkStmt popInstr in
	    let popBlock = mkBlock [ popStmt; mkStmt s.skind ] in
	    s.skind <- Block popBlock;
	    SkipChildren
        | _ -> DoChildren
      end
  end

(* Rewrite calls to hs_typeof(X) to the appropriate "rc_adjust..."
   function, or to null.
   hs_typeof is a macro that expands to 
     'sizeof(X) + __hs_magic_typeof' 
   and can thus be used to get both the type of types and expressions. *)
class crcTypeOf (fi:file) : cilVisitor =
  object (self)
    inherit nopCilVisitor as super

    val currentGlob : varinfo ref = ref dummyFunDec.svar;
    method vglob (g:global) = match g with
      | GVar (v, _, _) | GFun ({svar = v}, _) ->
        currentGlob := v;
        DoChildren
      | _ -> DoChildren

    method vexpr (e:exp) =  
      match e with
      | BinOp(PlusA, typeinfo, Lval(Var vi, NoOffset), _) 
        when vi.vname = "__hs_magic_typeof" ->
          begin
            try
              let t = rcSizeOfType typeinfo in 
              let vi = cRcAdjustForType fi !currentGlob t !currentLoc in
              ChangeTo (mkAddrOf (var vi))
            with 
            | NoRcPointers -> ChangeTo zero
            | NoType ->
                ignore (errorLoc !currentLoc "Invalid use of __hs_magic_typeof");
                DoChildren  
          end
      | Lval (Var vi,_)  when vi.vname = "__hs_magic_typeof" ->
          ignore(errorLoc !currentLoc "Invalid use of __hs_magic_typeof");
          DoChildren
      | _ -> DoChildren
  end

class nonCheckVarFinderClass (vs : VS.t ref) (change : bool ref)= object(self)
    inherit nopCilVisitor

    method vlval (lv : lval) =
        match lv with
        | (Mem e, _) -> begin
            let refd = UD.computeUseExp e in
            if VS.exists (fun vi -> not(VS.mem vi (!vs))) refd then begin
                vs := VS.union (UD.computeUseExp e) (!vs);
                change := true
            end;
            DoChildren
        end
        | _ -> DoChildren

    method vinst (i : instr) =
        if is_check_instr i then DoChildren else
        match i with
        | Set((Var vi, NoOffset),e,_) ->
            if VS.mem vi (!vs) then begin
                let refd = UD.computeUseExp e in
                if VS.exists (fun vi -> not(VS.mem vi (!vs))) refd then begin
                    vs := VS.union (UD.computeUseExp e) (!vs);
                    change := true
                end
            end;
            SkipChildren
        | Set(lv,e,_) ->
            let refd = VS.union (UD.computeUseExp e) (UD.computeUseExp(Lval lv)) in
            if VS.exists (fun vi -> not(VS.mem vi (!vs))) refd then begin
                vs := VS.union (UD.computeUseExp e) (!vs);
                change := true
            end;
            vs := VS.union refd (!vs);
            SkipChildren
        | Call(Some(Var vi,NoOffset),_,args,_) ->
            List.iter (fun e ->
                let refd = UD.computeUseExp e in
                if VS.exists (fun vi -> not(VS.mem vi (!vs))) refd then begin
                    vs := VS.union (UD.computeUseExp e) (!vs);
                    change := true
                end) args;
            SkipChildren
        | Call(Some lv,_,args,_) ->
            List.iter (fun e ->
                let refd = UD.computeUseExp e in
                if VS.exists (fun vi -> not(VS.mem vi (!vs))) refd then begin
                    vs := VS.union (UD.computeUseExp e) (!vs);
                    change := true
                end)
                ((Lval lv)::args);
            SkipChildren
        | Call(None,_,args,_) ->
            List.iter (fun e ->
                let refd = UD.computeUseExp e in
                if VS.exists (fun vi -> not(VS.mem vi (!vs))) refd then begin
                    vs := VS.union (UD.computeUseExp e) (!vs);
                    change := true
                end)
                args;
            SkipChildren
        | _ -> SkipChildren

    method vstmt (s : stmt) =
        match s.skind with
        | Return(Some e, _) ->
            let refd = UD.computeUseExp e in
            if VS.exists (fun vi -> not(VS.mem vi (!vs))) refd then begin
                vs := VS.union (UD.computeUseExp e) (!vs);
                change := true
            end;
            SkipChildren
        | _ -> DoChildren

end

let derefedVars (f : fundec) : VS.t =
    let change = ref false in
    let dVars = ref VS.empty in
    let vis = new nonCheckVarFinderClass dVars change in
    let rec loop () =
        ignore(visitCilFunction vis f);
        if !change then begin
            change := false;
            loop()
        end
    in
    loop();
    !dVars

let mkSCastMsg (dst : lval) (src : exp) (loc : location) : exp =
    let dstr = sprint ~width:80 (sp_lval () dst) in
    let sstr = sprint ~width:80 (sp_exp () src) in
    let locstr = loc.file^":"^(string_of_int loc.line) in
    mkString(dstr^" <- "^sstr^" @ "^locstr)

let make_sharing_cast (fd : fundec) (dst : lval) (src : exp)
                      (baselv : lval) (loc : location)
                      : instr
    =
    let msg = mkSCastMsg dst src loc in
    let sz = SizeOfE(Lval(Mem src,NoOffset)) in
    let ba = CastE(TPtr(voidPtrType,[]),AddrOf baselv) in
    let lo, hi =
        if !Ivyoptions.noDeputy then
            CastE(uintType,Lval baselv),
            CastE(uintType,BinOp(PlusPI,CastE(uintType,Lval baselv),
                                 sz,TPtr(voidPtrType,[])))
        else
            let lo, hi = Dcheck.boundsForExp fd src in
            CastE(uintType,lo), CastE(uintType,hi)
    in
    begin
        match baselv with
        | (Var vi, NoOffset) when not(vi.vaddrof) && not(vi.vglob) ->
            vi.vaddrof <- true
        | _ -> ()
    end;
    (*E.log "emitting sharing cast(%a,%a,%a,%a,%a,%a)\n"
        d_exp src d_exp ba d_exp zero d_exp lo d_exp hi d_exp msg;*)
    Call(Some dst,v2e sfuncs.sharingcast,[src;ba;zero;lo;hi;msg],loc)

(* Instrument fi for concurrent reference counting *)
(*
  reference counting of oVars can't be deferred.
  instead, keep stack of all oVars for each thread, and process them
  independently of logs when a reference count is needed.
  null out things in oVars when they die.
  other variables are treated as before, but unoptimized locals are
  "invalidated" on function exit, so that their entries in the log can
  be ignored.

  XXX: getting rid of pushing and popping for longjump would be a good
  optimization. Whole program analysis for finding what things can be longjumped
  over?
 *)
let cRcProcessFile (fi : file) : unit =
  let doRcTypeOf = new crcTypeOf fi in
  let cRcProcess (f:fundec) (loc:location) : unit =
    (* oVars are invalidated when they are no longer live.
       uVars are invalidated at the end of the function *)
    let dVars = derefedVars f in
    let interesting vi = typeContainsCountedPointers vi.vtype &&
                         VS.mem vi dVars
    in
    let optimisable vi =
      (not vi.vaddrof) && (isPointer vi.vtype) && (not (!Ivyoptions.noDefer))
    in
    let optimised vi = (interesting vi) && (optimisable vi)
    and unoptimised vi = (interesting vi) && (not (optimisable vi)) in

    let allLocals = f.sformals @ f.slocals in

    let oVars, uVars, iVars = 
        L.filter optimised allLocals, L.filter unoptimised allLocals,
        L.filter interesting allLocals
    in

    let doAssigns = new cRcAssignments fi oVars dVars
    and doExit = new cRcOnExit fi uVars oVars
    and doRcTrace = new rcTrace fi 
    and doRcClear = new rcClear in

    (* refcount writes *)
    (*Liveness.debug := true;*)
    Cfg.clearCFGinfo f;
    ignore(Cfg.cfgFun f);
    Liveness.computeLiveness f;
    ignore (visitCilFunction doAssigns f); 

    (* refcount formals in uVars on function entry *)
    cRcOnEntry fi f (L.filter unoptimised f.sformals) loc;

    (* push address of locals in iVars to parallel stack on function entry, 
       for invalidation before a longjmp. push addresses of other locals
       for reference counting. *) 
    cPushOnEntry fi f iVars oVars loc;

    (* pop address of local in uVars from parallel stack on function exit
       (for longjmp), and deref them *)
    if uVars <> [] || oVars <> [] then
      ignore (visitCilFunction doExit f);

    (* transform __builtin_clear to the appropriate clearing statements *)
    ignore (visitCilFunction doRcClear f);

    ignore (visitCilFunction (new rcCheckBadFunc) f);

    (* add tracing calls *)
    ignore (visitCilFunction doRcTrace f);

  in
  Sutil.convertSCASTs fi make_sharing_cast;
  let rcProcessGlobal (g:global) : unit =
    (* transform hs_typeof to the appropriate value *)
    ignore (visitCilGlobal doRcTypeOf g)
    
  in
  iterGlobals fi (onlyFunctions (skipAdjustFunctions cRcProcess));
  iterGlobals fi rcProcessGlobal
